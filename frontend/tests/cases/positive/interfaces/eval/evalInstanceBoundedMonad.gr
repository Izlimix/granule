-- EXPECTED: Some Id 8
interface Functor (f : Type -> Type) (c : Interval Nat) where
  map : forall {a : Type, b : Type} . (a -> b) [c] -> f a -> f b

interface {Functor f c} => Applicative (f : Type -> Type) (c : Interval Nat) where
  pureA : forall {a : Type} . a -> f a;
  ap : forall {a : Type, b : Type} . f ((a -> b) [c]) -> f (a [c]) -> f b

interface {Applicative m c} => Monad (m : Type -> Type) (c : Interval Nat) where
  bind : forall {a : Type, b : Type} . m a -> (a -> m b) [c] -> m b


data Id a = Id a

instance Functor Id [1..1] where
  map [f] (Id x) = Id (f x)

instance Applicative Id [1..1] where
  pureA = Id;
  ap (Id [f]) (Id [x]) = Id (f x)

instance Monad Id [1..1] where
  bind (Id x) [f] = f x

data Maybe a = None | Some a

instance Functor Maybe [0..1] where
  map [_] None = None;
  map [f] (Some x) = Some (f x)

instance Applicative Maybe [0..1] where
  pureA = Some;
  ap None None = None;
  ap None (Some [_]) = None;
  ap (Some [_]) None = None;
  ap (Some [f]) (Some [x]) = Some (f x)

instance Monad Maybe [0..1] where
  bind None [_] = None;
  bind (Some x) [f] = f x

main : Maybe (Id Int)
main = bind (pureA (pureA 7)) [\x -> pureA (map [\y -> y + 1] x)]
