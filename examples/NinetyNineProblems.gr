-- 99 problems in Granule! (https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems)

---------------------
----- Problem 1 -----
---------------------

-- Find the last element of a list


-- first define what a list is:

data List a = Empty | Next a (List a)

-- we don't always have a last element, so use a 'Maybe'
-- type to represent this:

data Maybe a = None | Some a

-- we are only going to use one of the
-- elements, so we use the grade '0..1'
-- to indicate this
last : forall {a : Type} . List (a [0..1]) -> Maybe a
last Empty            = None;
last (Next [x] Empty) = Some x;
last (Next [_] xs)    = last xs

-- alternatively, we can rebuild the initial part of the
-- list as we go. In this case, our result type is a pair,
-- containing all of the list bar the last element in the
-- first component of the pair, and a value indicating
-- whether or not there was a last element, along with that
-- value (if it exists), in the second.
--
-- notice that we no longer use the '0..1' grade, as we
-- consume every value in the list once, as we build up
-- the result
last' : forall {a : Type} . List a -> (List a, Maybe a)
last' Empty = (Empty, None);
last' (Next x Empty) = (Empty, Some x);
last' (Next x xs) =
  let (init, lastElem) = last' xs
  in (Next x init, lastElem)


---------------------
----- Problem 2 -----
---------------------

-- Find the last but one element of a list


-- very similar to the approach before, we just
-- adjust our pattern matching

lastButOne : forall {a : Type} . List (a [0..1]) -> Maybe a
lastButOne Empty                       = None;
lastButOne (Next [_] Empty)            = None;
lastButOne (Next [_] (Next [x] Empty)) = Some x;
lastButOne (Next [_] xs)               = lastButOne xs

lastButOne' : forall {a : Type} . List a -> (List a, Maybe a)
lastButOne' Empty                   = (Empty, None);
lastButOne' (Next x Empty)          = (Next x Empty, None);
lastButOne' (Next x (Next y Empty)) = (Next y Empty, Some x);
lastButOne' (Next x xs) =
  let (init, lastButOneElem) = lastButOne' xs
  in (Next x init, lastButOneElem)


---------------------
----- Problem 3 -----
---------------------

-- Find the K'th element of a list. The first element in the list is number 1.


-- we can first define a data type for positive naturals
--
-- where 'Z1' represents the number '1', and 'S1 x' represents '1 + x'
data Nat1 = Z1 | S1 Nat1


-- let's use that same notion of building up the list without the specified
-- element, so that we can use every element once.
--
-- we give a '0..1' grade to our input number, as if it so happens that
-- the number is greater than the length of our list, it doesn't make sense
-- to use it
elementAt : forall {a : Type} . List a -> Nat1 [0..1] -> (List a, Maybe a)
elementAt Empty [_] = (Empty, None);
elementAt (Next x xs) [Z1] = (xs, Some x);
elementAt (Next x xs) [S1 k] =
  let (rest, elem) = elementAt xs [k]
  in (Next x rest, elem)


-- What if we wanted to not do this re-building pattern? We just wanted
-- to indicate that we might not use elements of the list?
--
-- Let's try an implementation, following that idea:
--
-- elementAt : forall {a : Type} . List (a [0..1]) -> Nat1 [0..1] -> Maybe a
-- elementAt Empty [_] = None;
-- elementAt (Next [x] xs) [Z1] = Some x;
-- elementAt (Next [_] xs) [S1 k] = elementAt xs k
--
-- The second clause yields issue here:
--
-- elementAt (Next [x] xs) [Z1] = Some x
--
-- 'xs' has type 'List (a [0..1])', i.e., it is linear.
-- To respect linearity, we _must_ use that 'xs', but we can't,
-- so this definition won't work.


---------------------
----- Problem 4 -----
---------------------

-- Find the number of elements of a list


-- presently, `Nat' does not have kind `Type',
-- so we just define a simple type-level Nat:
data Nat' = Z | S Nat'


-- we can define a non re-building version of `length'
-- as follows. Rather than using a '0..1' grade as in
-- previous examples, we just use a '0' grade, indicating
-- that we consume none of the values in our list in the
-- production of the result.
length : forall {a : Type} . List (a [0]) -> Nat'
length Empty = Z;
length (Next [_] xs) = S (length xs)

-- we can define a re-building version in the same
-- manner as before
length' : forall {a : Type} . List a -> (List a, Nat')
length' Empty = (Empty, Z);
length' (Next x xs) =
  let (rest, len) = length' xs
  in (Next x rest, S len)


---------------------
----- Problem 5 -----
---------------------

-- Reverse a list


-- it is interesting to note that in a linear language,
-- such as Granule, the semantics of the type
-- 'List a -> List a' carry the same information as the
-- type 'Vec n a -> Vec n a', that is to say,
-- we know that any operation 'List a -> List a' must
-- preserve length (and elements), which is the same
-- as for 'Vec n a -> Vec n a'.
--
-- it is also important to note that 'List a -> List a'
-- has _more_ semantics in a linear language than
-- 'Vec n a -> Vec n a' in a non-linear one. Whilst
-- the latter does indicate that the length will stay
-- the same, it does allow you to e.g., forget some elements
-- whilst duplicating others. The linear version does not.
reverse : forall {a : Type} . List a -> List a
reverse Empty = Empty;
reverse (Next x Empty) = Next x Empty;
reverse (Next x (Next y ys)) = Next y (reverse (Next x ys))
